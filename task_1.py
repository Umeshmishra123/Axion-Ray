# -*- coding: utf-8 -*-
"""Task-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tDq2X1eDFP0SPpSSwm1TbW59TV-RSQcp

**Task-1**
"""

import pandas as pd

# Load the Excel file to examine its structure and contents
file_path = '/content/Task 1.xlsx'
excel_data = pd.ExcelFile(file_path)

# Display sheet names to understand the structure of the file
excel_data.sheet_names

"""The Excel file contains two sheets: Task and Taxonomy. I will first review the content of both sheets to understand the data structure and identify the required columns for tagging. â€‹"""

# Load and preview the content of the "Task" sheet
task_data = excel_data.parse('Task')
task_data.head()

"""The Task sheet contains free-text data across columns like Complaint, Cause, and Correction, with partial tagging already available in columns such as Root Cause, Symptom Condition, Symptom Component, and Fix Condition/Component. Some rows lack complete tagging.

Next, I'll examine the Taxonomy sheet to understand the predefined categories for mapping.
"""

# Load and preview the content of the "Taxonomy" sheet
taxonomy_data = excel_data.parse('Taxonomy')
taxonomy_data.head()

"""The Taxonomy sheet provides predefined categories for:

Root Cause

Symptom Condition

Symptom Component

Fix Condition

Fix Component

Approach

**Preprocessing:**

Standardize the text data in both the Task and Taxonomy sheets for case insensitivity.
Remove unnecessary spaces and handle missing data.
Tagging using Fuzzy Matching:

Use the fuzzywuzzy library to match free-text entries (e.g., Complaint, Cause, Correction) to the categories in the Taxonomy sheet.
Tag rows based on the closest match for each field.
Generate Results:

Create a new DataFrame with the tagged data.
Fill missing values where possible based on logical inference or matching.
Insights:

Highlight patterns or potential insights for larger datasets.
"""

!pip install fuzzywuzzy

from fuzzywuzzy import process

# Preprocess function for cleaning text data
def clean_text(text):
    if pd.isnull(text):
        return ""
    return str(text).strip().lower()

# Apply preprocessing to both datasets
task_data_clean = task_data.copy()
taxonomy_data_clean = taxonomy_data.copy()

for column in ['Complaint', 'Cause', 'Correction']:
    task_data_clean[column] = task_data_clean[column].apply(clean_text)

for column in taxonomy_data.columns:
    taxonomy_data_clean[column] = taxonomy_data_clean[column].apply(clean_text)

# Define a function for fuzzy matching to taxonomy categories
def fuzzy_match(value, category_list, threshold=80):
    if not value:
        return None
    match, score = process.extractOne(value, category_list)
    return match if score >= threshold else None

# Prepare lists for taxonomy categories
taxonomy_categories = {
    "Root Cause": taxonomy_data_clean["Root Cause"].unique().tolist(),
    "Symptom Condition": taxonomy_data_clean["Symptom Condition "].unique().tolist(),
    "Symptom Component": taxonomy_data_clean["Symptom Component"].unique().tolist(),
    "Fix Condition": taxonomy_data_clean["Fix Condition"].unique().tolist(),
    "Fix Component": taxonomy_data_clean["Fix Component"].unique().tolist(),
}

# Perform tagging for a sample subset of the data
sample_data = task_data_clean.head(10).copy()
for category, options in taxonomy_categories.items():
    sample_data[category] = sample_data['Complaint'].apply(lambda x: fuzzy_match(x, options))

sample_data.head()

# Install rapidfuzz
!pip install rapidfuzz

"""Write the Preprocessing Function

Use the function below to clean the text data in your dataset:
"""

def clean_text(text):
    if pd.isnull(text):
        return ""
    return str(text).strip().lower()

"""Use Fuzzy Matching with rapidfuzz"""

from rapidfuzz import process

def fuzzy_match(value, category_list, threshold=80):
    if not value:
        return None
    match, score = process.extractOne(value, category_list)
    return match if score >= threshold else None

"""Apply Fuzzy Matching to Your Dataset"""

from rapidfuzz import process

# Fuzzy matching function with corrected unpacking
def fuzzy_match(value, category_list, threshold=80):
    if not value:
        return None
    result = process.extractOne(value, category_list)
    if result:  # Ensure result is not None
        match, score, *_ = result  # Unpack match and score; ignore extra values
        return match if score >= threshold else None
    return None

# Load the dataset
file_path = 'Task 1.xlsx'  # Replace with your file path
excel_data = pd.ExcelFile(file_path)

# Load sheets
task_data = excel_data.parse('Task')
taxonomy_data = excel_data.parse('Taxonomy')

# Preprocess datasets
task_data_clean = task_data.copy()
taxonomy_data_clean = taxonomy_data.copy()

for column in ['Complaint', 'Cause', 'Correction']:
    task_data_clean[column] = task_data_clean[column].apply(clean_text)

for column in taxonomy_data.columns:
    taxonomy_data_clean[column] = taxonomy_data_clean[column].apply(clean_text)

# Prepare taxonomy categories
taxonomy_categories = {
    "Root Cause": taxonomy_data_clean["Root Cause"].unique().tolist(),
    "Symptom Condition ": taxonomy_data_clean["Symptom Condition "].unique().tolist(),
    "Symptom Component": taxonomy_data_clean["Symptom Component"].unique().tolist(),
    "Fix Condition": taxonomy_data_clean["Fix Condition"].unique().tolist(),
    "Fix Component": taxonomy_data_clean["Fix Component"].unique().tolist(),
}

# Perform tagging
for category, options in taxonomy_categories.items():
    task_data_clean[category] = task_data_clean['Complaint'].apply(lambda x: fuzzy_match(x, options))

# Save the tagged dataset
output_path = 'Tagged_Task_Data.xlsx'
task_data_clean.to_excel(output_path, index=False)
print(f"Tagged dataset saved to {output_path}")

"""Summary Report"""

Approach to Tagging:

Preprocessing: Cleaned the text data to remove inconsistencies (case sensitivity, extra spaces, etc.).

Matching: Used fuzzy matching to align text entries with predefined categories in the taxonomy.

Threshold: Set a matching threshold of 80% to ensure accurate matches.


Insights for a Larger Dataset:

Common root causes and fixes can identify recurring problems.
Time-to-resolution patterns can highlight areas for process improvement.
Department or product-specific analysis may reveal systemic issues.
"""





